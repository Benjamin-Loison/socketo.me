<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="generator" content="ApiGen 2.8.0" />

	<title>Class React\Stream\BufferedSink | Ratchet</title>

	<script type="text/javascript" src="resources/combined.js?1933933094"></script>
	<script type="text/javascript" src="elementlist.js?2449285623"></script>
	<link rel="stylesheet" type="text/css" media="all" href="resources/style.css?3505392360" />

</head>

<body>
<div id="left">
	<div id="menu">
		<a href="index.html" title="Overview"><span>Overview</span></a>


		<div id="groups">
			<h3>Namespaces</h3>
			<ul>
				<li><a href="namespace-Evenement.html">Evenement</a>
						</li>
				<li><a href="namespace-None.html">None</a>
						</li>
				<li><a href="namespace-PHP.html">PHP</a>
						</li>
				<li><a href="namespace-Psr.html">Psr<span></span></a>
						<ul>
				<li><a href="namespace-Psr.Http.html">Http<span></span></a>
						<ul>
				<li><a href="namespace-Psr.Http.Message.html">Message</a>
						</li>
							</ul></li></ul></li>
				<li><a href="namespace-Ratchet.html">Ratchet<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Http.html">Http</a>
						</li>
				<li><a href="namespace-Ratchet.RFC6455.html">RFC6455<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.RFC6455.Handshake.html">Handshake</a>
						</li>
				<li><a href="namespace-Ratchet.RFC6455.Messaging.html">Messaging</a>
						</li>
							</ul></li>
				<li><a href="namespace-Ratchet.Server.html">Server</a>
						</li>
				<li><a href="namespace-Ratchet.Session.html">Session<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Session.Serialize.html">Serialize</a>
						</li>
				<li><a href="namespace-Ratchet.Session.Storage.html">Storage<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Session.Storage.Proxy.html">Proxy</a>
						</li>
							</ul></li></ul></li>
				<li><a href="namespace-Ratchet.Wamp.html">Wamp</a>
						</li>
				<li><a href="namespace-Ratchet.WebSocket.html">WebSocket</a>
						</li>
							</ul></li>
				<li class="active"><a href="namespace-React.html">React<span></span></a>
						<ul>
				<li><a href="namespace-React.EventLoop.html">EventLoop<span></span></a>
						<ul>
				<li><a href="namespace-React.EventLoop.Tick.html">Tick</a>
						</li>
				<li><a href="namespace-React.EventLoop.Timer.html">Timer</a>
						</li>
							</ul></li>
				<li><a href="namespace-React.Socket.html">Socket</a>
						</li>
				<li class="active"><a href="namespace-React.Stream.html">Stream</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.html">Symfony<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.html">Component<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.html">HttpFoundation<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.html">Session<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Attribute.html">Attribute</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Flash.html">Flash</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.html">Storage<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.Handler.html">Handler</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.Proxy.html">Proxy</a>
						</li>
							</ul></li></ul></li></ul></li>
				<li><a href="namespace-Symfony.Component.Routing.html">Routing<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Annotation.html">Annotation</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Exception.html">Exception</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Generator.html">Generator<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Generator.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Loader.html">Loader<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Loader.DependencyInjection.html">DependencyInjection</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Matcher.html">Matcher<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Matcher.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.html">Tests<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Annotation.html">Annotation</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.html">Fixtures<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.AnnotatedClasses.html">AnnotatedClasses</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.OtherAnnotatedClasses.html">OtherAnnotatedClasses</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Generator.html">Generator<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Generator.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Loader.html">Loader</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Matcher.html">Matcher<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Matcher.Dumper.html">Dumper</a>
						</li>
							</ul></li></ul></li></ul></li></ul></li></ul></li>
			</ul>
		</div>

		<hr />


		<div id="elements">
			<h3>Classes</h3>
			<ul>
				<li class="active"><a href="class-React.Stream.BufferedSink.html">BufferedSink</a></li>
				<li><a href="class-React.Stream.CompositeStream.html">CompositeStream</a></li>
				<li><a href="class-React.Stream.DuplexResourceStream.html">DuplexResourceStream</a></li>
				<li><a href="class-React.Stream.ReadableResourceStream.html">ReadableResourceStream</a></li>
				<li><a href="class-React.Stream.ReadableStream.html">ReadableStream</a></li>
				<li><a href="class-React.Stream.ThroughStream.html">ThroughStream</a></li>
				<li><a href="class-React.Stream.Util.html">Util</a></li>
				<li><a href="class-React.Stream.WritableResourceStream.html">WritableResourceStream</a></li>
				<li><a href="class-React.Stream.WritableStream.html">WritableStream</a></li>
			</ul>

			<h3>Interfaces</h3>
			<ul>
				<li><a href="class-React.Stream.DuplexStreamInterface.html">DuplexStreamInterface</a></li>
				<li><a href="class-React.Stream.ReadableStreamInterface.html">ReadableStreamInterface</a></li>
				<li><a href="class-React.Stream.WritableStreamInterface.html">WritableStreamInterface</a></li>
			</ul>




		</div>
	</div>
</div>

<div id="splitter"></div>

<div id="right">
<div id="rightInner">
	<form id="search">
		<input type="hidden" name="cx" value="" />
		<input type="hidden" name="ie" value="UTF-8" />
		<input type="text" name="q" class="text" />
		<input type="submit" value="Search" />
	</form>

	<div id="navigation">
		<ul>
			<li>
				<a href="index.html" title="Overview"><span>Overview</span></a>
			</li>
			<li>
				<a href="namespace-React.Stream.html" title="Summary of React\Stream"><span>Namespace</span></a>
			</li>
			<li class="active">
<span>Class</span>			</li>
		</ul>
		<ul>
			<li>
				<a href="tree.html" title="Tree view of classes, interfaces, traits and exceptions"><span>Tree</span></a>
			</li>
		</ul>
		<ul>
		</ul>
	</div>

<div id="content" class="class">
	<h1>Class BufferedSink</h1>


	<div class="description">
	
<p>The <code>WritableStreamInterface</code> is responsible for providing an
interface for write-only streams and the writable side of duplex streams.</p>

<p>Besides defining a few methods, this interface also implements the
<code>EventEmitterInterface</code> which allows you to react to certain
events:</p>

<p>drain event: The <code>drain</code> event will be emitted whenever the write
buffer became full previously and is now ready to accept more data.<br />
<code>`</code>php $stream-&gt;on('drain', function () use ($stream) { echo
'Stream is now ready to accept more data'; }); <code>`</code><br />
This event SHOULD be emitted once every time the buffer became full previously
and is now ready to accept more data. In other words, this event MAY be emitted
any number of times, which may be zero times if the buffer never became full in
the first place. This event SHOULD NOT be emitted if the buffer has not become
full previously.<br />
This event is mostly used internally, see also <code>write()</code> for more
details.</p>

<p>pipe event: The <code>pipe</code> event will be emitted whenever a readable
stream is <code>pipe()</code>d into this stream. The event receives a single
<code>ReadableStreamInterface</code> argument for the source stream.<br />
<code>`</code>php $stream-&gt;on('pipe', function (ReadableStreamInterface
$source) use ($stream) { echo 'Now receiving piped data';<br />
// explicitly close target if source emits an error $source-&gt;on('error',
function () use ($stream) { $stream-&gt;close(); }); });<br />
$source-&gt;pipe($stream); <code>`</code><br />
This event MUST be emitted once for each readable stream that is successfully
piped into this destination stream. In other words, this event MAY be emitted
any number of times, which may be zero times if no stream is ever piped into
this stream. This event MUST NOT be emitted if either the source is not readable
(closed already) or this destination is not writable (closed already).<br />
This event is mostly used internally, see also <code>pipe()</code> for more
details.</p>

<p>error event: The <code>error</code> event will be emitted whenever an error
occurs, usually while trying to write to this stream. The event receives a
single <code>Exception</code> argument for the error instance.<br />
<code>`</code>php $stream-&gt;on('error', function (Exception $e) { echo 'Error:
' . $e-&gt;getMessage() . PHP_EOL; }); <code>`</code><br />
This event MAY be emitted any number of times, which should be zero times if
this is a stream that is successfully terminated. It SHOULD be emitted whenever
the stream detects an error, such as a transmission error. It SHOULD NOT be
emitted after a <code>close</code> event.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) only
deal with data transmission and may choose to only emit this for a fatal
transmission error once and will thus likely close (terminate) the stream in
response. If this is a fatal error that results in the stream being closed, it
SHOULD be followed by a <code>close</code> event.<br />
Other higher-level protocols may choose to keep the stream alive after this
event, if they can recover from an error condition.<br />
If this stream is a <code>DuplexStreamInterface</code>, you should also notice
how the readable side of the stream also implements an <code>error</code> event.
In other words, an error may occur while either reading or writing the stream
which should result in the same error processing.</p>

<p>close event: The <code>close</code> event will be emitted once the stream
closes (terminates).<br />
<code>`</code>php $stream-&gt;on('close', function () { echo 'CLOSED'; });
<code>`</code><br />
This event SHOULD be emitted once or never at all, depending on whether the
stream ever terminates. It SHOULD NOT be emitted after a previous
<code>close</code> event.<br />
After the stream is closed, it MUST switch to non-writable mode, see also
<code>isWritable()</code>.<br />
This event SHOULD be emitted whenever the stream closes, irrespective of whether
this happens implicitly due to an unrecoverable error or explicitly when either
side closes the stream.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) will
likely choose to emit this event after flushing the buffer from the
<code>end()</code> method, after receiving a <em>successful</em>
<code>end</code> event or after a fatal transmission <code>error</code>
event.<br />
If this stream is a <code>DuplexStreamInterface</code>, you should also notice
how the readable side of the stream also implements a <code>close</code> event.
In other words, after receiving this event, the stream MUST switch into
non-writable AND non-readable mode, see also <code>isReadable()</code>. Note
that this event should not be confused with the <code>end</code> event.</p>

	</div>

	<dl class="tree">
		<dd style="padding-left:0px">
			<a href="class-Evenement.EventEmitter.html"><span>Evenement\EventEmitter</span></a>
			
			 implements 
				<a href="class-Evenement.EventEmitterInterface.html"><span>Evenement\EventEmitterInterface</span></a>
			
			 uses 
				<a href="class-Evenement.EventEmitterTrait.html"><span>Evenement\EventEmitterTrait</span></a>
			
		</dd>
		<dd style="padding-left:30px">
			<img src="resources/inherit.png" alt="Extended by" />
			<a href="class-React.Stream.WritableStream.html"><span>React\Stream\WritableStream</span></a>
			
			 implements 
				<a href="class-React.Stream.WritableStreamInterface.html"><span>React\Stream\WritableStreamInterface</span></a>
			
			
		</dd>
		<dd style="padding-left:60px">
			<img src="resources/inherit.png" alt="Extended by" />
<b><span>React\Stream\BufferedSink</span></b>			
			 implements 
<span>React\Promise\PromisorInterface</span>
			
			
		</dd>
	</dl>








	<div class="info">
		
		
		<b>Namespace:</b> <a href="namespace-React.html">React</a>\<a href="namespace-React.Stream.html">Stream</a><br />
		

				<b>See:</b>
				EventEmitterInterface<br />
				<b>See:</b>
				<code><code><a href="class-React.Stream.DuplexStreamInterface.html">React\Stream\DuplexStreamInterface</a></code></code><br />
		<b>Located at</b> <a href="source-class-React.Stream.BufferedSink.html#8-66" title="Go to source code">BufferedSink.php</a><br />
	</div>



	<table class="summary" id="methods">
	<caption>Methods summary</caption>
	<tr data-order="__construct" id="___construct">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#___construct">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#13-19" title="Go to source code">__construct</a>( )</code>

		<div class="description short">
			
		</div>

		<div class="description detailed hidden">
			







		</div>
		</div></td>
	</tr>
	<tr data-order="handlePipeEvent" id="_handlePipeEvent">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_handlePipeEvent">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#21-25" title="Go to source code">handlePipeEvent</a>( <span>mixed <var>$source</var></span> )</code>

		<div class="description short">
			
		</div>

		<div class="description detailed hidden">
			







		</div>
		</div></td>
	</tr>
	<tr data-order="handleErrorEvent" id="_handleErrorEvent">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_handleErrorEvent">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#27-30" title="Go to source code">handleErrorEvent</a>( <span>mixed <var>$e</var></span> )</code>

		<div class="description short">
			
		</div>

		<div class="description detailed hidden">
			







		</div>
		</div></td>
	</tr>
	<tr data-order="write" id="_write">

		<td class="attributes"><code>
			 public 
			boolean
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_write">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#32-42" title="Go to source code">write</a>( <span>mixed|string <var>$data</var></span> )</code>

		<div class="description short">
			
<p>Write some data into the stream.</p>

		</div>

		<div class="description detailed hidden">
			
<p>Write some data into the stream.</p>

<p>A successful write MUST be confirmed with a boolean <code>true</code>, which
means that either the data was written (flushed) immediately or is buffered and
scheduled for a future write. Note that this interface gives you no control over
explicitly flushing the buffered data, as finding the appropriate time for this
is beyond the scope of this interface and left up to the implementation of this
interface.</p>

<p>Many common streams (such as a TCP/IP connection or file-based stream) may
choose to buffer all given data and schedule a future flush by using an
underlying EventLoop to check when the resource is actually writable.</p>

<p>If a stream cannot handle writing (or flushing) the data, it SHOULD emit an
<code>error</code> event and MAY <code>close()</code> the stream if it can not
recover from this error.</p>

<p>If the internal buffer is full after adding <code>$data</code>, then
<code>write()</code> SHOULD return <code>false</code>, indicating that the
caller should stop sending data until the buffer drains. The stream SHOULD send
a <code>drain</code> event once the buffer is ready to accept more data.</p>

<p>Similarly, if the the stream is not writable (already in a closed state) it
MUST NOT process the given <code>$data</code> and SHOULD return
<code>false</code>, indicating that the caller should stop sending data.</p>

<p>The given <code>$data</code> argument MAY be of mixed type, but it's usually
recommended it SHOULD be a <code>string</code> value or MAY use a type that
allows representation as a <code>string</code> for maximum compatibility.</p>

<p>Many common streams (such as a TCP/IP connection or a file-based stream) will
only accept the raw (binary) payload data that is transferred over the wire as
chunks of <code>string</code> values.</p>

<p>Due to the stream-based nature of this, the sender may send any number of
chunks with varying sizes. There are no guarantees that these chunks will be
received with the exact same framing the sender intended to send. In other
words, many lower-level protocols (such as TCP/IP) transfer the data in chunks
that may be anywhere between single-byte values to several dozens of kilobytes.
You may want to apply a higher-level protocol to these low-level data chunks in
order to achieve proper message framing.</p>



				<h4>Parameters</h4>
				<div class="list"><dl>
					<dt><var>$data</var></dt>
					<dd><code>mixed|string</code><br>$data</dd>
				</dl></div>

				<h4>Returns</h4>
				<div class="list">
					<code>boolean</code><br />
				</div>



				<h4>Overrides</h4>
				<div class="list"><code><a href="class-React.Stream.WritableStream.html#_write">React\Stream\WritableStream::write()</a></code></div>

		</div>
		</div></td>
	</tr>
	<tr data-order="close" id="_close">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_close">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#44-52" title="Go to source code">close</a>( )</code>

		<div class="description short">
			
<p>Closes the stream (forcefully).</p>

		</div>

		<div class="description detailed hidden">
			
<p>Closes the stream (forcefully).</p>

<p>This method can be used to forcefully close the stream, i.e. close the stream
without waiting for any buffered data to be flushed. If there's still data in
the buffer, this data SHOULD be discarded.</p>

<p><code>`</code>php $stream-&gt;close(); <code>`</code></p>

<p>Once the stream is closed, it SHOULD emit a <code>close</code> event. Note
that this event SHOULD NOT be emitted more than once, in particular if this
method is called multiple times.</p>

<p>After calling this method, the stream MUST switch into a non-writable mode,
see also <code>isWritable()</code>. This means that no further writes are
possible, so any additional <code>write()</code> or <code>end()</code> calls
have no effect.</p>

<p><code>`</code>php $stream-&gt;close(); assert($stream-&gt;isWritable() ===
false);</p>

<p>$stream-&gt;write('nope'); // NO-OP $stream-&gt;end(); // NO-OP
<code>`</code></p>

<p>Note that this method should not be confused with the <code>end()</code>
method. Unlike the <code>end()</code> method, this method does not take care of
any existing buffers and simply discards any buffer contents. Likewise, this
method may also be called after calling <code>end()</code> on a stream in order
to stop waiting for the stream to flush its final data.</p>

<p><code>`</code>php $stream-&gt;end(); $loop-&gt;addTimer(1.0, function () use
($stream) { $stream-&gt;close(); }); <code>`</code></p>

<p>If this stream is a <code>DuplexStreamInterface</code>, you should also
notice how the readable side of the stream also implements a
<code>close()</code> method. In other words, after calling this method, the
stream MUST switch into non-writable AND non-readable mode, see also
<code>isReadable()</code>.</p>






				<h4>See</h4>
				<div class="list">
						<code><code><a href="class-React.Stream.ReadableStreamInterface.html#_close">React\Stream\ReadableStreamInterface::close()</a></code></code><br />
				</div>

				<h4>Overrides</h4>
				<div class="list"><code><a href="class-React.Stream.WritableStream.html#_close">React\Stream\WritableStream::close()</a></code></div>

		</div>
		</div></td>
	</tr>
	<tr data-order="promise" id="_promise">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_promise">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#54-57" title="Go to source code">promise</a>( )</code>

		<div class="description short">
			
		</div>

		<div class="description detailed hidden">
			







		</div>
		</div></td>
	</tr>
	<tr data-order="createPromise" id="_createPromise">

		<td class="attributes"><code>
			 public static
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_createPromise">#</a>
		<code><a href="source-class-React.Stream.BufferedSink.html#59-65" title="Go to source code">createPromise</a>( <span><code><a href="class-React.Stream.ReadableStreamInterface.html">React\Stream\ReadableStreamInterface</a></code> <var>$stream</var></span> )</code>

		<div class="description short">
			
		</div>

		<div class="description detailed hidden">
			







		</div>
		</div></td>
	</tr>
	</table>

	<table class="summary inherited">
	<caption>Methods inherited from <a href="class-React.Stream.WritableStream.html#methods">React\Stream\WritableStream</a></caption>
	<tr>
		<td><code>
			<a href="class-React.Stream.WritableStream.html#_end">end()</a>, 
			<a href="class-React.Stream.WritableStream.html#_isWritable">isWritable()</a>
		</code></td>
	</tr>
	</table>
	<table class="summary inherited">
	<caption>Methods inherited from <a href="class-Evenement.EventEmitterInterface.html#methods">Evenement\EventEmitterInterface</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterInterface.html#_emit">emit()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_listeners">listeners()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_on">on()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_once">once()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_removeAllListeners">removeAllListeners()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_removeListener">removeListener()</a>
		</code></td>
	</tr>
	</table>

	<table class="summary used">
	<caption>Methods used from <a href="class-Evenement.EventEmitterTrait.html#methods">Evenement\EventEmitterTrait</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterTrait.html#_emit">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_listeners">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_on">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_once">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_removeAllListeners">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_removeListener">()</a>
		</code></td>
	</tr>
	</table>











	<table class="summary inherited">
	<caption>Properties inherited from <a href="class-React.Stream.WritableStream.html#properties">React\Stream\WritableStream</a></caption>
	<tr>
		<td><code>
			<a href="class-React.Stream.WritableStream.html#$closed"><var>$closed</var></a>
		</code></td>
	</tr>
	</table>

	<table class="summary used">
	<caption>Properties used from <a href="class-Evenement.EventEmitterTrait.html#properties">Evenement\EventEmitterTrait</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterTrait.html#$listeners"><var>$listeners</var></a>
		</code></td>
	</tr>
	</table>




</div>

	<div id="footer">
		Ratchet API documentation generated by <a href="http://apigen.org">ApiGen 2.8.0</a>
	</div>
</div>
</div>
</body>
</html>
