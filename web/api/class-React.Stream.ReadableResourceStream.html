<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="generator" content="ApiGen 2.8.0" />

	<title>Class React\Stream\ReadableResourceStream | Ratchet</title>

	<script type="text/javascript" src="resources/combined.js?1933933094"></script>
	<script type="text/javascript" src="elementlist.js?2449285623"></script>
	<link rel="stylesheet" type="text/css" media="all" href="resources/style.css?3505392360" />

</head>

<body>
<div id="left">
	<div id="menu">
		<a href="index.html" title="Overview"><span>Overview</span></a>


		<div id="groups">
			<h3>Namespaces</h3>
			<ul>
				<li><a href="namespace-Evenement.html">Evenement</a>
						</li>
				<li><a href="namespace-None.html">None</a>
						</li>
				<li><a href="namespace-PHP.html">PHP</a>
						</li>
				<li><a href="namespace-Psr.html">Psr<span></span></a>
						<ul>
				<li><a href="namespace-Psr.Http.html">Http<span></span></a>
						<ul>
				<li><a href="namespace-Psr.Http.Message.html">Message</a>
						</li>
							</ul></li></ul></li>
				<li><a href="namespace-Ratchet.html">Ratchet<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Http.html">Http</a>
						</li>
				<li><a href="namespace-Ratchet.RFC6455.html">RFC6455<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.RFC6455.Handshake.html">Handshake</a>
						</li>
				<li><a href="namespace-Ratchet.RFC6455.Messaging.html">Messaging</a>
						</li>
							</ul></li>
				<li><a href="namespace-Ratchet.Server.html">Server</a>
						</li>
				<li><a href="namespace-Ratchet.Session.html">Session<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Session.Serialize.html">Serialize</a>
						</li>
				<li><a href="namespace-Ratchet.Session.Storage.html">Storage<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Session.Storage.Proxy.html">Proxy</a>
						</li>
							</ul></li></ul></li>
				<li><a href="namespace-Ratchet.Wamp.html">Wamp</a>
						</li>
				<li><a href="namespace-Ratchet.WebSocket.html">WebSocket</a>
						</li>
							</ul></li>
				<li class="active"><a href="namespace-React.html">React<span></span></a>
						<ul>
				<li><a href="namespace-React.EventLoop.html">EventLoop<span></span></a>
						<ul>
				<li><a href="namespace-React.EventLoop.Tick.html">Tick</a>
						</li>
				<li><a href="namespace-React.EventLoop.Timer.html">Timer</a>
						</li>
							</ul></li>
				<li><a href="namespace-React.Socket.html">Socket</a>
						</li>
				<li class="active"><a href="namespace-React.Stream.html">Stream</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.html">Symfony<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.html">Component<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.html">HttpFoundation<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.html">Session<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Attribute.html">Attribute</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Flash.html">Flash</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.html">Storage<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.Handler.html">Handler</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.Proxy.html">Proxy</a>
						</li>
							</ul></li></ul></li></ul></li>
				<li><a href="namespace-Symfony.Component.Routing.html">Routing<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Annotation.html">Annotation</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Exception.html">Exception</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Generator.html">Generator<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Generator.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Loader.html">Loader<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Loader.DependencyInjection.html">DependencyInjection</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Matcher.html">Matcher<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Matcher.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.html">Tests<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Annotation.html">Annotation</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.html">Fixtures<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.AnnotatedClasses.html">AnnotatedClasses</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.OtherAnnotatedClasses.html">OtherAnnotatedClasses</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Generator.html">Generator<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Generator.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Loader.html">Loader</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Matcher.html">Matcher<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Matcher.Dumper.html">Dumper</a>
						</li>
							</ul></li></ul></li></ul></li></ul></li></ul></li>
			</ul>
		</div>

		<hr />


		<div id="elements">
			<h3>Classes</h3>
			<ul>
				<li><a href="class-React.Stream.BufferedSink.html">BufferedSink</a></li>
				<li><a href="class-React.Stream.CompositeStream.html">CompositeStream</a></li>
				<li><a href="class-React.Stream.DuplexResourceStream.html">DuplexResourceStream</a></li>
				<li class="active"><a href="class-React.Stream.ReadableResourceStream.html">ReadableResourceStream</a></li>
				<li><a href="class-React.Stream.ReadableStream.html">ReadableStream</a></li>
				<li><a href="class-React.Stream.ThroughStream.html">ThroughStream</a></li>
				<li><a href="class-React.Stream.Util.html">Util</a></li>
				<li><a href="class-React.Stream.WritableResourceStream.html">WritableResourceStream</a></li>
				<li><a href="class-React.Stream.WritableStream.html">WritableStream</a></li>
			</ul>

			<h3>Interfaces</h3>
			<ul>
				<li><a href="class-React.Stream.DuplexStreamInterface.html">DuplexStreamInterface</a></li>
				<li><a href="class-React.Stream.ReadableStreamInterface.html">ReadableStreamInterface</a></li>
				<li><a href="class-React.Stream.WritableStreamInterface.html">WritableStreamInterface</a></li>
			</ul>




		</div>
	</div>
</div>

<div id="splitter"></div>

<div id="right">
<div id="rightInner">
	<form id="search">
		<input type="hidden" name="cx" value="" />
		<input type="hidden" name="ie" value="UTF-8" />
		<input type="text" name="q" class="text" />
		<input type="submit" value="Search" />
	</form>

	<div id="navigation">
		<ul>
			<li>
				<a href="index.html" title="Overview"><span>Overview</span></a>
			</li>
			<li>
				<a href="namespace-React.Stream.html" title="Summary of React\Stream"><span>Namespace</span></a>
			</li>
			<li class="active">
<span>Class</span>			</li>
		</ul>
		<ul>
			<li>
				<a href="tree.html" title="Tree view of classes, interfaces, traits and exceptions"><span>Tree</span></a>
			</li>
		</ul>
		<ul>
		</ul>
	</div>

<div id="content" class="class">
	<h1>Class ReadableResourceStream</h1>


	<div class="description">
	
<p>The <code>ReadableStreamInterface</code> is responsible for providing an
interface for read-only streams and the readable side of duplex streams.</p>

<p>Besides defining a few methods, this interface also implements the
<code>EventEmitterInterface</code> which allows you to react to certain
events:</p>

<p>data event: The <code>data</code> event will be emitted whenever some data
was read/received from this source stream. The event receives a single mixed
argument for incoming data.<br />
<code>`</code>php $stream-&gt;on('data', function ($data) { echo $data; });
<code>`</code><br />
This event MAY be emitted any number of times, which may be zero times if this
stream does not send any data at all. It SHOULD not be emitted after an
<code>end</code> or <code>close</code> event.<br />
The given <code>$data</code> argument may be of mixed type, but it's usually
recommended it SHOULD be a <code>string</code> value or MAY use a type that
allows representation as a <code>string</code> for maximum compatibility.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) will
emit the raw (binary) payload data that is received over the wire as chunks of
<code>string</code> values.<br />
Due to the stream-based nature of this, the sender may send any number of chunks
with varying sizes. There are no guarantees that these chunks will be received
with the exact same framing the sender intended to send. In other words, many
lower-level protocols (such as TCP/IP) transfer the data in chunks that may be
anywhere between single-byte values to several dozens of kilobytes. You may want
to apply a higher-level protocol to these low-level data chunks in order to
achieve proper message framing.</p>

<p>end event: The <code>end</code> event will be emitted once the source stream
has successfully reached the end of the stream (EOF).<br />
<code>`</code>php $stream-&gt;on('end', function () { echo 'END'; });
<code>`</code><br />
This event SHOULD be emitted once or never at all, depending on whether a
successful end was detected. It SHOULD NOT be emitted after a previous
<code>end</code> or <code>close</code> event. It MUST NOT be emitted if the
stream closes due to a non-successful end, such as after a previous
<code>error</code> event.<br />
After the stream is ended, it MUST switch to non-readable mode, see also
<code>isReadable()</code>.<br />
This event will only be emitted if the <em>end</em> was reached successfully,
not if the stream was interrupted by an unrecoverable error or explicitly
closed. Not all streams know this concept of a "successful end". Many use-cases
involve detecting when the stream closes (terminates) instead, in this case you
should use the <code>close</code> event. After the stream emits an
<code>end</code> event, it SHOULD usually be followed by a <code>close</code>
event.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) will
emit this event if either the remote side closes the connection or a file handle
was successfully read until reaching its end (EOF).<br />
Note that this event should not be confused with the <code>end()</code> method.
This event defines a successful end <em>reading</em> from a source stream, while
the <code>end()</code> method defines <em>writing</em> a successful end to a
destination stream.</p>

<p>error event: The <code>error</code> event will be emitted whenever an error
occurs, usually while trying to read from this stream. The event receives a
single <code>Exception</code> argument for the error instance.<br />
<code>`</code>php $stream-&gt;on('error', function (Exception $e) { echo 'Error:
' . $e-&gt;getMessage() . PHP_EOL; }); <code>`</code><br />
This event MAY be emitted any number of times, which should be zero times if
this is a stream that is successfully terminated. It SHOULD be emitted whenever
the stream detects an error, such as a transmission error or after an unexpected
<code>data</code> or premature <code>end</code> event. It SHOULD NOT be emitted
after a <code>close</code> event.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) only
deal with data transmission and do not make assumption about data boundaries
(such as unexpected <code>data</code> or premature <code>end</code> events). In
other words, many lower-level protocols (such as TCP/IP) may choose to only emit
this for a fatal transmission error once and will thus likely close (terminate)
the stream in response. If this is a fatal error that results in the stream
being closed, it SHOULD be followed by a <code>close</code> event.<br />
Other higher-level protocols may choose to keep the stream alive after this
event, if they can recover from an error condition.<br />
If this stream is a <code>DuplexStreamInterface</code>, you should also notice
how the writable side of the stream also implements an <code>error</code> event.
In other words, an error may occur while either reading or writing the stream
which should result in the same error processing.</p>

<p>close event: The <code>close</code> event will be emitted once the stream
closes (terminates).<br />
<code>`</code>php $stream-&gt;on('close', function () { echo 'CLOSED'; });
<code>`</code><br />
This event SHOULD be emitted once or never at all, depending on whether the
stream ever terminates. It SHOULD NOT be emitted after a previous
<code>close</code> event.<br />
After the stream is closed, it MUST switch to non-readable mode, see also
<code>isReadable()</code>.<br />
Unlike the <code>end</code> event, this event SHOULD be emitted whenever the
stream closes, irrespective of whether this happens implicitly due to an
unrecoverable error or explicitly when either side closes the stream. If you
only want to detect a <em>succesful</em> end, you should use the
<code>end</code> event instead.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) will
likely choose to emit this event after reading a <em>successful</em>
<code>end</code> event or after a fatal transmission <code>error</code>
event.<br />
If this stream is a <code>DuplexStreamInterface</code>, you should also notice
how the writable side of the stream also implements a <code>close</code> event.
In other words, after receiving this event, the stream MUST switch into
non-writable AND non-readable mode, see also <code>isWritable()</code>. Note
that this event should not be confused with the <code>end</code> event.</p>

	</div>

	<dl class="tree">
		<dd style="padding-left:0px">
			<a href="class-Evenement.EventEmitter.html"><span>Evenement\EventEmitter</span></a>
			
			 implements 
				<a href="class-Evenement.EventEmitterInterface.html"><span>Evenement\EventEmitterInterface</span></a>
			
			 uses 
				<a href="class-Evenement.EventEmitterTrait.html"><span>Evenement\EventEmitterTrait</span></a>
			
		</dd>
		<dd style="padding-left:30px">
			<img src="resources/inherit.png" alt="Extended by" />
<b><span>React\Stream\ReadableResourceStream</span></b>			
			 implements 
				<a href="class-React.Stream.ReadableStreamInterface.html"><span>React\Stream\ReadableStreamInterface</span></a>
			
			
		</dd>
	</dl>








	<div class="info">
		
		
		<b>Namespace:</b> <a href="namespace-React.html">React</a>\<a href="namespace-React.Stream.html">Stream</a><br />
		

				<b>See:</b>
				EventEmitterInterface<br />
		<b>Located at</b> <a href="source-class-React.Stream.ReadableResourceStream.html#9-172" title="Go to source code">ReadableResourceStream.php</a><br />
	</div>



	<table class="summary" id="methods">
	<caption>Methods summary</caption>
	<tr data-order="__construct" id="___construct">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#___construct">#</a>
		<code><a href="source-class-React.Stream.ReadableResourceStream.html#39-73" title="Go to source code">__construct</a>( <span>mixed <var>$stream</var></span>, <span><code><a href="class-React.EventLoop.LoopInterface.html">React\EventLoop\LoopInterface</a></code> <var>$loop</var></span> )</code>

		<div class="description short">
			
		</div>

		<div class="description detailed hidden">
			







		</div>
		</div></td>
	</tr>
	<tr data-order="isReadable" id="_isReadable">

		<td class="attributes"><code>
			 public 
			boolean
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_isReadable">#</a>
		<code><a href="source-class-React.Stream.ReadableResourceStream.html#75-78" title="Go to source code">isReadable</a>( )</code>

		<div class="description short">
			
<p>Checks whether this stream is in a readable state (not closed already).</p>

		</div>

		<div class="description detailed hidden">
			
<p>Checks whether this stream is in a readable state (not closed already).</p>

<p>This method can be used to check if the stream still accepts incoming data
events or if it is ended or closed already. Once the stream is non-readable, no
further <code>data</code> or <code>end</code> events SHOULD be emitted.</p>

<p><code>`</code>php assert($stream-&gt;isReadable() === false);</p>

<p>$stream-&gt;on('data', assertNeverCalled()); $stream-&gt;on('end',
assertNeverCalled()); <code>`</code></p>

<p>A successfully opened stream always MUST start in readable mode.</p>

<p>Once the stream ends or closes, it MUST switch to non-readable mode. This can
happen any time, explicitly through <code>close()</code> or implicitly due to a
remote close or an unrecoverable transmission error. Once a stream has switched
to non-readable mode, it MUST NOT transition back to readable mode.</p>

<p>If this stream is a <code>DuplexStreamInterface</code>, you should also
notice how the writable side of the stream also implements an
<code>isWritable()</code> method. Unless this is a half-open duplex stream, they
SHOULD usually have the same return value.</p>




				<h4>Returns</h4>
				<div class="list">
					<code>boolean</code><br />
				</div>




				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.ReadableStreamInterface.html#_isReadable">React\Stream\ReadableStreamInterface::isReadable()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="pause" id="_pause">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_pause">#</a>
		<code><a href="source-class-React.Stream.ReadableResourceStream.html#80-83" title="Go to source code">pause</a>( )</code>

		<div class="description short">
			
<p>Pauses reading incoming data events.</p>

		</div>

		<div class="description detailed hidden">
			
<p>Pauses reading incoming data events.</p>

<p>Removes the data source file descriptor from the event loop. This allows you
to throttle incoming data.</p>

<p>Unless otherwise noted, a successfully opened stream SHOULD NOT start in
paused state.</p>

<p>Once the stream is paused, no futher <code>data</code> or <code>end</code>
events SHOULD be emitted.</p>

<p><code>`</code>php $stream-&gt;pause();</p>

<p>$stream-&gt;on('data', assertShouldNeverCalled()); $stream-&gt;on('end',
assertShouldNeverCalled()); <code>`</code></p>

<p>This method is advisory-only, though generally not recommended, the stream
MAY continue emitting <code>data</code> events.</p>

<p>You can continue processing events by calling <code>resume()</code>
again.</p>

<p>Note that both methods can be called any number of times, in particular
calling <code>pause()</code> more than once SHOULD NOT have any effect.</p>






				<h4>See</h4>
				<div class="list">
						<code><code><a href="class-React.Stream.ReadableResourceStream.html#_resume">React\Stream\ReadableResourceStream::resume()</a></code></code><br />
				</div>


				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.ReadableStreamInterface.html#_pause">React\Stream\ReadableStreamInterface::pause()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="resume" id="_resume">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_resume">#</a>
		<code><a href="source-class-React.Stream.ReadableResourceStream.html#85-90" title="Go to source code">resume</a>( )</code>

		<div class="description short">
			
<p>Resumes reading incoming data events.</p>

		</div>

		<div class="description detailed hidden">
			
<p>Resumes reading incoming data events.</p>

<p>Re-attach the data source after a previous <code>pause()</code>.</p>

<p><code>`</code>php $stream-&gt;pause();</p>

<p>$loop-&gt;addTimer(1.0, function () use ($stream) { $stream-&gt;resume(); });
<code>`</code></p>

<p>Note that both methods can be called any number of times, in particular
calling <code>resume()</code> without a prior <code>pause()</code> SHOULD NOT
have any effect.</p>






				<h4>See</h4>
				<div class="list">
						<code><code><a href="class-React.Stream.ReadableResourceStream.html#_pause">React\Stream\ReadableResourceStream::pause()</a></code></code><br />
				</div>


				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.ReadableStreamInterface.html#_resume">React\Stream\ReadableStreamInterface::resume()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="pipe" id="_pipe">

		<td class="attributes"><code>
			 public 
			<code><a href="class-React.Stream.WritableStreamInterface.html">React\Stream\WritableStreamInterface</a></code>
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_pipe">#</a>
		<code><a href="source-class-React.Stream.ReadableResourceStream.html#92-95" title="Go to source code">pipe</a>( <span><code><a href="class-React.Stream.WritableStreamInterface.html">React\Stream\WritableStreamInterface</a></code> <var>$dest</var></span>, <span>array <var>$options</var> = <span class="php-keyword1">array</span>()</span> )</code>

		<div class="description short">
			
<p>Pipes all the data from this readable source into the given writable
destination.</p>

		</div>

		<div class="description detailed hidden">
			
<p>Pipes all the data from this readable source into the given writable
destination.</p>

<p>Automatically sends all incoming data to the destination. Automatically
throttles the source based on what the destination can handle.</p>

<p><code>`</code>php $source-&gt;pipe($dest); <code>`</code></p>

<p>Similarly, you can also pipe an instance implementing
<code>DuplexStreamInterface</code> into itself in order to write back all the
data that is received. This may be a useful feature for a TCP/IP echo
service:</p>

<p><code>`</code>php $connection-&gt;pipe($connection); <code>`</code></p>

<p>This method returns the destination stream as-is, which can be used to set up
chains of piped streams:</p>

<p><code>`</code>php
$source-&gt;pipe($decodeGzip)-&gt;pipe($filterBadWords)-&gt;pipe($dest);
<code>`</code></p>

<p>By default, this will call <code>end()</code> on the destination stream once
the source stream emits an <code>end</code> event. This can be disabled like
this:</p>

<p><code>`</code>php $source-&gt;pipe($dest, array('end' =&gt; false));
<code>`</code></p>

<p>Note that this only applies to the <code>end</code> event. If an
<code>error</code> or explicit <code>close</code> event happens on the source
stream, you'll have to manually close the destination stream:</p>

<p><code>`</code>php $source-&gt;pipe($dest); $source-&gt;on('close', function
() use ($dest) { $dest-&gt;end('BYE!'); }); <code>`</code></p>

<p>If the source stream is not readable (closed state), then this is a
NO-OP.</p>

<p><code>`</code>php $source-&gt;close(); $source-&gt;pipe($dest); // NO-OP
<code>`</code></p>

<p>If the destinantion stream is not writable (closed state), then this will
simply throttle (pause) the source stream:</p>

<p><code>`</code>php $dest-&gt;close(); $source-&gt;pipe($dest); // calls
$source-&gt;pause() <code>`</code></p>

<p>Similarly, if the destination stream is closed while the pipe is still
active, it will also throttle (pause) the source stream:</p>

<p><code>`</code>php $source-&gt;pipe($dest); $dest-&gt;close(); // calls
$source-&gt;pause() <code>`</code></p>

<p>Once the pipe is set up successfully, the destination stream MUST emit a
<code>pipe</code> event with this source stream an event argument.</p>



				<h4>Parameters</h4>
				<div class="list"><dl>
					<dt><var>$dest</var></dt>
					<dd><code><code><a href="class-React.Stream.WritableStreamInterface.html">React\Stream\WritableStreamInterface</a></code></code><br>$dest</dd>
					<dt><var>$options</var></dt>
					<dd><code>array</code><br>$options</dd>
				</dl></div>

				<h4>Returns</h4>
				<div class="list">
					<code><code><a href="class-React.Stream.WritableStreamInterface.html">React\Stream\WritableStreamInterface</a></code></code><br>$dest stream as-is<br />
				</div>




				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.ReadableStreamInterface.html#_pipe">React\Stream\ReadableStreamInterface::pipe()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="close" id="_close">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_close">#</a>
		<code><a href="source-class-React.Stream.ReadableResourceStream.html#97-110" title="Go to source code">close</a>( )</code>

		<div class="description short">
			
<p>Closes the stream (forcefully).</p>

		</div>

		<div class="description detailed hidden">
			
<p>Closes the stream (forcefully).</p>

<p>This method can be used to (forcefully) close the stream.</p>

<p><code>`</code>php $stream-&gt;close(); <code>`</code></p>

<p>Once the stream is closed, it SHOULD emit a <code>close</code> event. Note
that this event SHOULD NOT be emitted more than once, in particular if this
method is called multiple times.</p>

<p>After calling this method, the stream MUST switch into a non-readable mode,
see also <code>isReadable()</code>. This means that no further <code>data</code>
or <code>end</code> events SHOULD be emitted.</p>

<p><code>`</code>php $stream-&gt;close(); assert($stream-&gt;isReadable() ===
false);</p>

<p>$stream-&gt;on('data', assertNeverCalled()); $stream-&gt;on('end',
assertNeverCalled()); <code>`</code></p>

<p>If this stream is a <code>DuplexStreamInterface</code>, you should also
notice how the writable side of the stream also implements a
<code>close()</code> method. In other words, after calling this method, the
stream MUST switch into non-writable AND non-readable mode, see also
<code>isWritable()</code>. Note that this method should not be confused with the
<code>end()</code> method.</p>






				<h4>See</h4>
				<div class="list">
						<code><code><a href="class-React.Stream.WritableStreamInterface.html#_close">React\Stream\WritableStreamInterface::close()</a></code></code><br />
				</div>


				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.ReadableStreamInterface.html#_close">React\Stream\ReadableStreamInterface::close()</a></code></div>
		</div>
		</div></td>
	</tr>
	</table>

	<table class="summary inherited">
	<caption>Methods inherited from <a href="class-Evenement.EventEmitterInterface.html#methods">Evenement\EventEmitterInterface</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterInterface.html#_emit">emit()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_listeners">listeners()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_on">on()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_once">once()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_removeAllListeners">removeAllListeners()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_removeListener">removeListener()</a>
		</code></td>
	</tr>
	</table>

	<table class="summary used">
	<caption>Methods used from <a href="class-Evenement.EventEmitterTrait.html#methods">Evenement\EventEmitterTrait</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterTrait.html#_emit">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_listeners">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_on">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_once">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_removeAllListeners">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_removeListener">()</a>
		</code></td>
	</tr>
	</table>










	<table class="summary" id="properties">
	<caption>Properties summary</caption>
	<tr data-order="bufferSize" id="$bufferSize">
		<td class="attributes"><code>
			public  
			integer|null
		</code></td>

		<td class="name">
				<a href="source-class-React.Stream.ReadableResourceStream.html#11-29" title="Go to source code"><var>$bufferSize</var></a>
		</td>
		<td class="value"><code><span class="php-num">65536</span></code></td>
		<td class="description"><div>
			<a href="#$bufferSize" class="anchor">#</a>

			<div class="description short">
				
<p>Controls the maximum buffer size in bytes to read at once from the
stream.</p>

			</div>

			<div class="description detailed hidden">
				
<p>Controls the maximum buffer size in bytes to read at once from the
stream.</p>

<p>This value SHOULD NOT be changed unless you know what you're doing.</p>

<p>This can be a positive number which means that up to X bytes will be read at
once from the underlying stream resource. Note that the actual number of bytes
read may be lower if the stream resource has less than X bytes currently
available.</p>

<p>This can be <code>null</code> which means read everything available from the
underlying stream resource. This should read until the stream resource is not
readable anymore (i.e. underlying buffer drained), note that this does not
neccessarily mean it reached EOF.</p>


			</div>
		</div></td>
	</tr>
	<tr data-order="stream" id="$stream">
		<td class="attributes"><code>
			public  
			resource
		</code></td>

		<td class="name">
				<a href="source-class-React.Stream.ReadableResourceStream.html#31-34" title="Go to source code"><var>$stream</var></a>
		</td>
		<td class="value"><code></code></td>
		<td class="description"><div>
			<a href="#$stream" class="anchor">#</a>

			<div class="description short">
				
			</div>

			<div class="description detailed hidden">
				

			</div>
		</div></td>
	</tr>
	</table>


	<table class="summary used">
	<caption>Properties used from <a href="class-Evenement.EventEmitterTrait.html#properties">Evenement\EventEmitterTrait</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterTrait.html#$listeners"><var>$listeners</var></a>
		</code></td>
	</tr>
	</table>




</div>

	<div id="footer">
		Ratchet API documentation generated by <a href="http://apigen.org">ApiGen 2.8.0</a>
	</div>
</div>
</div>
</body>
</html>
