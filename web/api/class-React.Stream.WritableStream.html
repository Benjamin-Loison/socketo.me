<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="generator" content="ApiGen 2.8.0" />

	<title>Class React\Stream\WritableStream | Ratchet</title>

	<script type="text/javascript" src="resources/combined.js?1933933094"></script>
	<script type="text/javascript" src="elementlist.js?2449285623"></script>
	<link rel="stylesheet" type="text/css" media="all" href="resources/style.css?3505392360" />

</head>

<body>
<div id="left">
	<div id="menu">
		<a href="index.html" title="Overview"><span>Overview</span></a>


		<div id="groups">
			<h3>Namespaces</h3>
			<ul>
				<li><a href="namespace-Evenement.html">Evenement</a>
						</li>
				<li><a href="namespace-None.html">None</a>
						</li>
				<li><a href="namespace-PHP.html">PHP</a>
						</li>
				<li><a href="namespace-Psr.html">Psr<span></span></a>
						<ul>
				<li><a href="namespace-Psr.Http.html">Http<span></span></a>
						<ul>
				<li><a href="namespace-Psr.Http.Message.html">Message</a>
						</li>
							</ul></li></ul></li>
				<li><a href="namespace-Ratchet.html">Ratchet<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Http.html">Http</a>
						</li>
				<li><a href="namespace-Ratchet.RFC6455.html">RFC6455<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.RFC6455.Handshake.html">Handshake</a>
						</li>
				<li><a href="namespace-Ratchet.RFC6455.Messaging.html">Messaging</a>
						</li>
							</ul></li>
				<li><a href="namespace-Ratchet.Server.html">Server</a>
						</li>
				<li><a href="namespace-Ratchet.Session.html">Session<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Session.Serialize.html">Serialize</a>
						</li>
				<li><a href="namespace-Ratchet.Session.Storage.html">Storage<span></span></a>
						<ul>
				<li><a href="namespace-Ratchet.Session.Storage.Proxy.html">Proxy</a>
						</li>
							</ul></li></ul></li>
				<li><a href="namespace-Ratchet.Wamp.html">Wamp</a>
						</li>
				<li><a href="namespace-Ratchet.WebSocket.html">WebSocket</a>
						</li>
							</ul></li>
				<li class="active"><a href="namespace-React.html">React<span></span></a>
						<ul>
				<li><a href="namespace-React.EventLoop.html">EventLoop<span></span></a>
						<ul>
				<li><a href="namespace-React.EventLoop.Tick.html">Tick</a>
						</li>
				<li><a href="namespace-React.EventLoop.Timer.html">Timer</a>
						</li>
							</ul></li>
				<li><a href="namespace-React.Socket.html">Socket</a>
						</li>
				<li class="active"><a href="namespace-React.Stream.html">Stream</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.html">Symfony<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.html">Component<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.html">HttpFoundation<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.html">Session<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Attribute.html">Attribute</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Flash.html">Flash</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.html">Storage<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.Handler.html">Handler</a>
						</li>
				<li><a href="namespace-Symfony.Component.HttpFoundation.Session.Storage.Proxy.html">Proxy</a>
						</li>
							</ul></li></ul></li></ul></li>
				<li><a href="namespace-Symfony.Component.Routing.html">Routing<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Annotation.html">Annotation</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Exception.html">Exception</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Generator.html">Generator<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Generator.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Loader.html">Loader<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Loader.DependencyInjection.html">DependencyInjection</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Matcher.html">Matcher<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Matcher.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.html">Tests<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Annotation.html">Annotation</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.html">Fixtures<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.AnnotatedClasses.html">AnnotatedClasses</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Fixtures.OtherAnnotatedClasses.html">OtherAnnotatedClasses</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Generator.html">Generator<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Generator.Dumper.html">Dumper</a>
						</li>
							</ul></li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Loader.html">Loader</a>
						</li>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Matcher.html">Matcher<span></span></a>
						<ul>
				<li><a href="namespace-Symfony.Component.Routing.Tests.Matcher.Dumper.html">Dumper</a>
						</li>
							</ul></li></ul></li></ul></li></ul></li></ul></li>
			</ul>
		</div>

		<hr />


		<div id="elements">
			<h3>Classes</h3>
			<ul>
				<li><a href="class-React.Stream.BufferedSink.html">BufferedSink</a></li>
				<li><a href="class-React.Stream.CompositeStream.html">CompositeStream</a></li>
				<li><a href="class-React.Stream.DuplexResourceStream.html">DuplexResourceStream</a></li>
				<li><a href="class-React.Stream.ReadableResourceStream.html">ReadableResourceStream</a></li>
				<li><a href="class-React.Stream.ReadableStream.html">ReadableStream</a></li>
				<li><a href="class-React.Stream.ThroughStream.html">ThroughStream</a></li>
				<li><a href="class-React.Stream.Util.html">Util</a></li>
				<li><a href="class-React.Stream.WritableResourceStream.html">WritableResourceStream</a></li>
				<li class="active"><a href="class-React.Stream.WritableStream.html">WritableStream</a></li>
			</ul>

			<h3>Interfaces</h3>
			<ul>
				<li><a href="class-React.Stream.DuplexStreamInterface.html">DuplexStreamInterface</a></li>
				<li><a href="class-React.Stream.ReadableStreamInterface.html">ReadableStreamInterface</a></li>
				<li><a href="class-React.Stream.WritableStreamInterface.html">WritableStreamInterface</a></li>
			</ul>




		</div>
	</div>
</div>

<div id="splitter"></div>

<div id="right">
<div id="rightInner">
	<form id="search">
		<input type="hidden" name="cx" value="" />
		<input type="hidden" name="ie" value="UTF-8" />
		<input type="text" name="q" class="text" />
		<input type="submit" value="Search" />
	</form>

	<div id="navigation">
		<ul>
			<li>
				<a href="index.html" title="Overview"><span>Overview</span></a>
			</li>
			<li>
				<a href="namespace-React.Stream.html" title="Summary of React\Stream"><span>Namespace</span></a>
			</li>
			<li class="active">
<span>Class</span>			</li>
		</ul>
		<ul>
			<li>
				<a href="tree.html" title="Tree view of classes, interfaces, traits and exceptions"><span>Tree</span></a>
			</li>
		</ul>
		<ul>
		</ul>
	</div>

<div id="content" class="class">
	<h1>Class WritableStream</h1>


	<div class="description">
	
<p>The <code>WritableStreamInterface</code> is responsible for providing an
interface for write-only streams and the writable side of duplex streams.</p>

<p>Besides defining a few methods, this interface also implements the
<code>EventEmitterInterface</code> which allows you to react to certain
events:</p>

<p>drain event: The <code>drain</code> event will be emitted whenever the write
buffer became full previously and is now ready to accept more data.<br />
<code>`</code>php $stream-&gt;on('drain', function () use ($stream) { echo
'Stream is now ready to accept more data'; }); <code>`</code><br />
This event SHOULD be emitted once every time the buffer became full previously
and is now ready to accept more data. In other words, this event MAY be emitted
any number of times, which may be zero times if the buffer never became full in
the first place. This event SHOULD NOT be emitted if the buffer has not become
full previously.<br />
This event is mostly used internally, see also <code>write()</code> for more
details.</p>

<p>pipe event: The <code>pipe</code> event will be emitted whenever a readable
stream is <code>pipe()</code>d into this stream. The event receives a single
<code>ReadableStreamInterface</code> argument for the source stream.<br />
<code>`</code>php $stream-&gt;on('pipe', function (ReadableStreamInterface
$source) use ($stream) { echo 'Now receiving piped data';<br />
// explicitly close target if source emits an error $source-&gt;on('error',
function () use ($stream) { $stream-&gt;close(); }); });<br />
$source-&gt;pipe($stream); <code>`</code><br />
This event MUST be emitted once for each readable stream that is successfully
piped into this destination stream. In other words, this event MAY be emitted
any number of times, which may be zero times if no stream is ever piped into
this stream. This event MUST NOT be emitted if either the source is not readable
(closed already) or this destination is not writable (closed already).<br />
This event is mostly used internally, see also <code>pipe()</code> for more
details.</p>

<p>error event: The <code>error</code> event will be emitted whenever an error
occurs, usually while trying to write to this stream. The event receives a
single <code>Exception</code> argument for the error instance.<br />
<code>`</code>php $stream-&gt;on('error', function (Exception $e) { echo 'Error:
' . $e-&gt;getMessage() . PHP_EOL; }); <code>`</code><br />
This event MAY be emitted any number of times, which should be zero times if
this is a stream that is successfully terminated. It SHOULD be emitted whenever
the stream detects an error, such as a transmission error. It SHOULD NOT be
emitted after a <code>close</code> event.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) only
deal with data transmission and may choose to only emit this for a fatal
transmission error once and will thus likely close (terminate) the stream in
response. If this is a fatal error that results in the stream being closed, it
SHOULD be followed by a <code>close</code> event.<br />
Other higher-level protocols may choose to keep the stream alive after this
event, if they can recover from an error condition.<br />
If this stream is a <code>DuplexStreamInterface</code>, you should also notice
how the readable side of the stream also implements an <code>error</code> event.
In other words, an error may occur while either reading or writing the stream
which should result in the same error processing.</p>

<p>close event: The <code>close</code> event will be emitted once the stream
closes (terminates).<br />
<code>`</code>php $stream-&gt;on('close', function () { echo 'CLOSED'; });
<code>`</code><br />
This event SHOULD be emitted once or never at all, depending on whether the
stream ever terminates. It SHOULD NOT be emitted after a previous
<code>close</code> event.<br />
After the stream is closed, it MUST switch to non-writable mode, see also
<code>isWritable()</code>.<br />
This event SHOULD be emitted whenever the stream closes, irrespective of whether
this happens implicitly due to an unrecoverable error or explicitly when either
side closes the stream.<br />
Many common streams (such as a TCP/IP connection or a file-based stream) will
likely choose to emit this event after flushing the buffer from the
<code>end()</code> method, after receiving a <em>successful</em>
<code>end</code> event or after a fatal transmission <code>error</code>
event.<br />
If this stream is a <code>DuplexStreamInterface</code>, you should also notice
how the readable side of the stream also implements a <code>close</code> event.
In other words, after receiving this event, the stream MUST switch into
non-writable AND non-readable mode, see also <code>isReadable()</code>. Note
that this event should not be confused with the <code>end</code> event.</p>

	</div>

	<dl class="tree">
		<dd style="padding-left:0px">
			<a href="class-Evenement.EventEmitter.html"><span>Evenement\EventEmitter</span></a>
			
			 implements 
				<a href="class-Evenement.EventEmitterInterface.html"><span>Evenement\EventEmitterInterface</span></a>
			
			 uses 
				<a href="class-Evenement.EventEmitterTrait.html"><span>Evenement\EventEmitterTrait</span></a>
			
		</dd>
		<dd style="padding-left:30px">
			<img src="resources/inherit.png" alt="Extended by" />
<b><span>React\Stream\WritableStream</span></b>			
			 implements 
				<a href="class-React.Stream.WritableStreamInterface.html"><span>React\Stream\WritableStreamInterface</span></a>
			
			
		</dd>
	</dl>


	<div>
		<h4>Direct known subclasses</h4>
			<a href="class-React.Stream.BufferedSink.html">React\Stream\BufferedSink</a>
	</div>






	<div class="info">
		
		
		<b>Namespace:</b> <a href="namespace-React.html">React</a>\<a href="namespace-React.Stream.html">Stream</a><br />
		

				<b>See:</b>
				EventEmitterInterface<br />
				<b>See:</b>
				<code><code><a href="class-React.Stream.DuplexStreamInterface.html">React\Stream\DuplexStreamInterface</a></code></code><br />
		<b>Located at</b> <a href="source-class-React.Stream.WritableStream.html#7-40" title="Go to source code">WritableStream.php</a><br />
	</div>



	<table class="summary" id="methods">
	<caption>Methods summary</caption>
	<tr data-order="write" id="_write">

		<td class="attributes"><code>
			 public 
			boolean
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_write">#</a>
		<code><a href="source-class-React.Stream.WritableStream.html#11-14" title="Go to source code">write</a>( <span>mixed|string <var>$data</var></span> )</code>

		<div class="description short">
			
<p>Write some data into the stream.</p>

		</div>

		<div class="description detailed hidden">
			
<p>Write some data into the stream.</p>

<p>A successful write MUST be confirmed with a boolean <code>true</code>, which
means that either the data was written (flushed) immediately or is buffered and
scheduled for a future write. Note that this interface gives you no control over
explicitly flushing the buffered data, as finding the appropriate time for this
is beyond the scope of this interface and left up to the implementation of this
interface.</p>

<p>Many common streams (such as a TCP/IP connection or file-based stream) may
choose to buffer all given data and schedule a future flush by using an
underlying EventLoop to check when the resource is actually writable.</p>

<p>If a stream cannot handle writing (or flushing) the data, it SHOULD emit an
<code>error</code> event and MAY <code>close()</code> the stream if it can not
recover from this error.</p>

<p>If the internal buffer is full after adding <code>$data</code>, then
<code>write()</code> SHOULD return <code>false</code>, indicating that the
caller should stop sending data until the buffer drains. The stream SHOULD send
a <code>drain</code> event once the buffer is ready to accept more data.</p>

<p>Similarly, if the the stream is not writable (already in a closed state) it
MUST NOT process the given <code>$data</code> and SHOULD return
<code>false</code>, indicating that the caller should stop sending data.</p>

<p>The given <code>$data</code> argument MAY be of mixed type, but it's usually
recommended it SHOULD be a <code>string</code> value or MAY use a type that
allows representation as a <code>string</code> for maximum compatibility.</p>

<p>Many common streams (such as a TCP/IP connection or a file-based stream) will
only accept the raw (binary) payload data that is transferred over the wire as
chunks of <code>string</code> values.</p>

<p>Due to the stream-based nature of this, the sender may send any number of
chunks with varying sizes. There are no guarantees that these chunks will be
received with the exact same framing the sender intended to send. In other
words, many lower-level protocols (such as TCP/IP) transfer the data in chunks
that may be anywhere between single-byte values to several dozens of kilobytes.
You may want to apply a higher-level protocol to these low-level data chunks in
order to achieve proper message framing.</p>



				<h4>Parameters</h4>
				<div class="list"><dl>
					<dt><var>$data</var></dt>
					<dd><code>mixed|string</code><br>$data</dd>
				</dl></div>

				<h4>Returns</h4>
				<div class="list">
					<code>boolean</code><br />
				</div>




				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.WritableStreamInterface.html#_write">React\Stream\WritableStreamInterface::write()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="end" id="_end">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_end">#</a>
		<code><a href="source-class-React.Stream.WritableStream.html#16-23" title="Go to source code">end</a>( <span>mixed|string|null <var>$data</var> = <span class="php-keyword1">null</span></span> )</code>

		<div class="description short">
			
<p>Successfully ends the stream (after optionally sending some final data).</p>

		</div>

		<div class="description detailed hidden">
			
<p>Successfully ends the stream (after optionally sending some final data).</p>

<p>This method can be used to successfully end the stream, i.e. close the stream
after sending out all data that is currently buffered.</p>

<p><code>`</code>php $stream-&gt;write('hello'); $stream-&gt;write('world');
$stream-&gt;end(); <code>`</code></p>

<p>If there's no data currently buffered and nothing to be flushed, then this
method MAY <code>close()</code> the stream immediately.</p>

<p>If there's still data in the buffer that needs to be flushed first, then this
method SHOULD try to write out this data and only then <code>close()</code> the
stream. Once the stream is closed, it SHOULD emit a <code>close</code>
event.</p>

<p>Note that this interface gives you no control over explicitly flushing the
buffered data, as finding the appropriate time for this is beyond the scope of
this interface and left up to the implementation of this interface.</p>

<p>Many common streams (such as a TCP/IP connection or file-based stream) may
choose to buffer all given data and schedule a future flush by using an
underlying EventLoop to check when the resource is actually writable.</p>

<p>You can optionally pass some final data that is written to the stream before
ending the stream. If a non-<code>null</code> value is given as
<code>$data</code>, then this method will behave just like calling
<code>write($data)</code> before ending with no data.</p>

<p><code>`</code>php // shorter version $stream-&gt;end('bye');</p>

<p>// same as longer version $stream-&gt;write('bye'); $stream-&gt;end();
<code>`</code></p>

<p>After calling this method, the stream MUST switch into a non-writable mode,
see also <code>isWritable()</code>. This means that no further writes are
possible, so any additional <code>write()</code> or <code>end()</code> calls
have no effect.</p>

<p><code>`</code>php $stream-&gt;end(); assert($stream-&gt;isWritable() ===
false);</p>

<p>$stream-&gt;write('nope'); // NO-OP $stream-&gt;end(); // NO-OP
<code>`</code></p>

<p>If this stream is a <code>DuplexStreamInterface</code>, calling this method
SHOULD also end its readable side, unless the stream supports half-open mode. In
other words, after calling this method, these streams SHOULD switch into
non-writable AND non-readable mode, see also <code>isReadable()</code>. This
implies that in this case, the stream SHOULD NOT emit any <code>data</code> or
<code>end</code> events anymore. Streams MAY choose to use the
<code>pause()</code> method logic for this, but special care may have to be
taken to ensure a following call to the <code>resume()</code> method SHOULD NOT
continue emitting readable events.</p>

<p>Note that this method should not be confused with the <code>close()</code>
method.</p>



				<h4>Parameters</h4>
				<div class="list"><dl>
					<dt><var>$data</var></dt>
					<dd><code>mixed|string|null</code><br>$data</dd>
				</dl></div>





				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.WritableStreamInterface.html#_end">React\Stream\WritableStreamInterface::end()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="isWritable" id="_isWritable">

		<td class="attributes"><code>
			 public 
			boolean
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_isWritable">#</a>
		<code><a href="source-class-React.Stream.WritableStream.html#25-28" title="Go to source code">isWritable</a>( )</code>

		<div class="description short">
			
<p>Checks whether this stream is in a writable state (not closed already).</p>

		</div>

		<div class="description detailed hidden">
			
<p>Checks whether this stream is in a writable state (not closed already).</p>

<p>This method can be used to check if the stream still accepts writing any data
or if it is ended or closed already. Writing any data to a non-writable stream
is a NO-OP:</p>

<p><code>`</code>php assert($stream-&gt;isWritable() === false);</p>

<p>$stream-&gt;write('end'); // NO-OP $stream-&gt;end('end'); // NO-OP
<code>`</code></p>

<p>A successfully opened stream always MUST start in writable mode.</p>

<p>Once the stream ends or closes, it MUST switch to non-writable mode. This can
happen any time, explicitly through <code>end()</code> or <code>close()</code>
or implicitly due to a remote close or an unrecoverable transmission error. Once
a stream has switched to non-writable mode, it MUST NOT transition back to
writable mode.</p>

<p>If this stream is a <code>DuplexStreamInterface</code>, you should also
notice how the readable side of the stream also implements an
<code>isReadable()</code> method. Unless this is a half-open duplex stream, they
SHOULD usually have the same return value.</p>




				<h4>Returns</h4>
				<div class="list">
					<code>boolean</code><br />
				</div>




				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.WritableStreamInterface.html#_isWritable">React\Stream\WritableStreamInterface::isWritable()</a></code></div>
		</div>
		</div></td>
	</tr>
	<tr data-order="close" id="_close">

		<td class="attributes"><code>
			 public 
			
			
			</code>
		</td>

		<td class="name"><div>
		<a class="anchor" href="#_close">#</a>
		<code><a href="source-class-React.Stream.WritableStream.html#30-39" title="Go to source code">close</a>( )</code>

		<div class="description short">
			
<p>Closes the stream (forcefully).</p>

		</div>

		<div class="description detailed hidden">
			
<p>Closes the stream (forcefully).</p>

<p>This method can be used to forcefully close the stream, i.e. close the stream
without waiting for any buffered data to be flushed. If there's still data in
the buffer, this data SHOULD be discarded.</p>

<p><code>`</code>php $stream-&gt;close(); <code>`</code></p>

<p>Once the stream is closed, it SHOULD emit a <code>close</code> event. Note
that this event SHOULD NOT be emitted more than once, in particular if this
method is called multiple times.</p>

<p>After calling this method, the stream MUST switch into a non-writable mode,
see also <code>isWritable()</code>. This means that no further writes are
possible, so any additional <code>write()</code> or <code>end()</code> calls
have no effect.</p>

<p><code>`</code>php $stream-&gt;close(); assert($stream-&gt;isWritable() ===
false);</p>

<p>$stream-&gt;write('nope'); // NO-OP $stream-&gt;end(); // NO-OP
<code>`</code></p>

<p>Note that this method should not be confused with the <code>end()</code>
method. Unlike the <code>end()</code> method, this method does not take care of
any existing buffers and simply discards any buffer contents. Likewise, this
method may also be called after calling <code>end()</code> on a stream in order
to stop waiting for the stream to flush its final data.</p>

<p><code>`</code>php $stream-&gt;end(); $loop-&gt;addTimer(1.0, function () use
($stream) { $stream-&gt;close(); }); <code>`</code></p>

<p>If this stream is a <code>DuplexStreamInterface</code>, you should also
notice how the readable side of the stream also implements a
<code>close()</code> method. In other words, after calling this method, the
stream MUST switch into non-writable AND non-readable mode, see also
<code>isReadable()</code>.</p>






				<h4>See</h4>
				<div class="list">
						<code><code><a href="class-React.Stream.ReadableStreamInterface.html#_close">React\Stream\ReadableStreamInterface::close()</a></code></code><br />
				</div>


				<h4>Implementation of</h4>
				<div class="list"><code><a href="class-React.Stream.WritableStreamInterface.html#_close">React\Stream\WritableStreamInterface::close()</a></code></div>
		</div>
		</div></td>
	</tr>
	</table>

	<table class="summary inherited">
	<caption>Methods inherited from <a href="class-Evenement.EventEmitterInterface.html#methods">Evenement\EventEmitterInterface</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterInterface.html#_emit">emit()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_listeners">listeners()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_on">on()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_once">once()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_removeAllListeners">removeAllListeners()</a>, 
			<a href="class-Evenement.EventEmitterInterface.html#_removeListener">removeListener()</a>
		</code></td>
	</tr>
	</table>

	<table class="summary used">
	<caption>Methods used from <a href="class-Evenement.EventEmitterTrait.html#methods">Evenement\EventEmitterTrait</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterTrait.html#_emit">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_listeners">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_on">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_once">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_removeAllListeners">()</a>, 
			<a href="class-Evenement.EventEmitterTrait.html#_removeListener">()</a>
		</code></td>
	</tr>
	</table>










	<table class="summary" id="properties">
	<caption>Properties summary</caption>
	<tr data-order="closed" id="$closed">
		<td class="attributes"><code>
			protected  
			boolean
		</code></td>

		<td class="name">
				<a href="source-class-React.Stream.WritableStream.html#9" title="Go to source code"><var>$closed</var></a>
		</td>
		<td class="value"><code><span class="php-keyword1">false</span></code></td>
		<td class="description"><div>
			<a href="#$closed" class="anchor">#</a>

			<div class="description short">
				
			</div>

			<div class="description detailed hidden">
				

			</div>
		</div></td>
	</tr>
	</table>


	<table class="summary used">
	<caption>Properties used from <a href="class-Evenement.EventEmitterTrait.html#properties">Evenement\EventEmitterTrait</a></caption>
	<tr>
		<td><code>
			<a href="class-Evenement.EventEmitterTrait.html#$listeners"><var>$listeners</var></a>
		</code></td>
	</tr>
	</table>




</div>

	<div id="footer">
		Ratchet API documentation generated by <a href="http://apigen.org">ApiGen 2.8.0</a>
	</div>
</div>
</div>
</body>
</html>
